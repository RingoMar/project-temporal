"use strict";(self.webpackChunkproject_temporal=self.webpackChunkproject_temporal||[]).push([[7866],{3905:(n,e,t)=>{t.d(e,{Zo:()=>m,kt:()=>d});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var l=r.createContext({}),c=function(n){var e=r.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},m=function(n){var e=c(n.components);return r.createElement(l.Provider,{value:e},n.children)},p="mdxType",g={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,a=n.originalType,l=n.parentName,m=o(n,["components","mdxType","originalType","parentName"]),p=c(t),u=i,d=p["".concat(l,".").concat(u)]||p[u]||g[u]||a;return t?r.createElement(d,s(s({ref:e},m),{},{components:t})):r.createElement(d,s({ref:e},m))}));function d(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=t.length,s=new Array(a);s[0]=u;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=n,o[p]="string"==typeof n?n:i,s[1]=o;for(var c=2;c<a;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5446:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const a={sidebar_position:2},s="Whisper Implementation",o={unversionedId:"tutorial-bot/whisper",id:"tutorial-bot/whisper",title:"Whisper Implementation",description:"A simple implementation of whisper that when syced up with the m3u8 downloader it keeps down the waste.",source:"@site/docs/tutorial-bot/whisper.md",sourceDirName:"tutorial-bot",slug:"/tutorial-bot/whisper",permalink:"/project-temporal/docs/tutorial-bot/whisper",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Get M3U8 Links",permalink:"/project-temporal/docs/tutorial-bot/get-m3u8"},next:{title:"What is Whisper",permalink:"/project-temporal/docs/about-whisper"}},l={},c=[{value:"Configure Golang server with twitch bot",id:"configure-golang-server-with-twitch-bot",level:2}],m={toc:c};function p(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,r.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"whisper-implementation"},"Whisper Implementation"),(0,i.kt)("p",null,"A simple implementation of whisper that when syced up with the m3u8 downloader it keeps down the waste.  "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"My devcontainer for the whisper ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/RingoMar/whisper-devcontainer"},"project"))),(0,i.kt)("p",null,"Create the main file ",(0,i.kt)("inlineCode",{parentName:"p"},"main.py"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This is a sample from my fbomb script")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},'import datetime\nimport json\nimport logging\nimport logging.handlers\nimport time\nimport os\nimport re\nimport time\n\nimport requests\nimport whisper\n\nmodel = whisper.load_model("base")\nfilesDone = []\n\nos.system("rm file.log")\n\nlogger = logging.getLogger(\'logit\')\nhandler = logging.handlers.RotatingFileHandler("file.log")\nhandler.setLevel(logging.DEBUG)\nformatter = logging.Formatter(\'%(asctime)s %(levelname)8s: %(message)s\')\nhandler.setFormatter(formatter)\nlogging.Formatter.converter = time.gmtime\nlogger.addHandler(handler)\nlogging.basicConfig(level=logging.DEBUG,\n                    format=\'%(asctime)s %(levelname)8s: %(message)s\')\n\nwhile True:\n    for x in os.listdir("./audio"):\n        logger.info(f"[+] Checking File: {x}")\n        try:\n            timestamp = os.path.getmtime("./audio/" + x)\n            datestamp = datetime.datetime.fromtimestamp(timestamp)\n            logger.debug(f\'Modified Date/Time: {datestamp}\')\n        except:\n            pass\n        if x in filesDone:\n            logger.warning(f"Skipping File {x}, I read this already.")\n            continue\n\n        filesDone.append(x)\n\n        try:\n            audio = whisper.load_audio("./audio/" + x)\n        except Exception as e:\n            logger.error(e)\n            continue\n        audio = whisper.pad_or_trim(audio)\n        mel = whisper.log_mel_spectrogram(audio).to(model.device)\n        _, probs = model.detect_language(mel)\n\n        logger.info(f"Detected language: {max(probs, key=probs.get)}")\n\n        options = whisper.DecodingOptions(fp16=False)\n        result = whisper.decode(model, mel, options)\n\n        logger.debug(f"-> Decoded Audio: {result.text}")\n\n        for match in re.finditer(r"fuck(s|ing|er)?", result.text):\n            logger.warning("Found: " + match.group())\n            access = requests.post(\n                \'http://127.0.0.1:8085/increment\', timeout=10)\n            logger.debug(access.text)\n\n        if len(filesDone) > 3:\n            logger.info("Cleaning up files")\n            for item in filesDone:\n                try:\n                    os.system("sudo rm ./audio/" + item)\n                except:\n                    pass\n            filesDone = []\n\n    logger.debug("-> Sleeping in anticipation for new files")\n    time.sleep(1)\n\n')),(0,i.kt)("h2",{id:"configure-golang-server-with-twitch-bot"},"Configure Golang server with twitch bot"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Custom IRC reader in go for twitch bot that is very flexable ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="main.go"',title:'"main.go"'},'package main\n\nimport (\n    "bufio"\n    "crypto/tls"\n    "encoding/json"\n    "fmt"\n    "io/ioutil"\n    "log"\n    "net"\n    "net/http"\n    "net/textproto"\n    "os"\n    "os/signal"\n    "regexp"\n    "strings"\n    "syscall"\n    "time"\n)\n\nvar lastUsed time.Time = time.Now().Add(200 * time.Second)\n\ntype myData struct {\n    Fbombs int `json:"fbombs"`\n}\n\ntype ircMessage struct {\n    Raw     string\n    Tags    map[string]string\n    Source  ircMessageSource\n    Command string\n    Params  []string\n}\n\ntype ircMessageSource struct {\n    Nickname string\n    Username string\n    Host     string\n}\n\nfunc parseIRCMessage(line string) (*ircMessage, error) {\n    message := ircMessage{\n        Raw:    line,\n        Tags:   make(map[string]string),\n        Params: []string{},\n    }\n\n    split := strings.Split(line, " ")\n    index := 0\n\n    if strings.HasPrefix(split[index], "@") {\n        message.Tags = parseIRCTags(split[index])\n        index++\n    }\n\n    if index >= len(split) {\n        return &message, fmt.Errorf("parseIRCMessage: partial message")\n    }\n\n    if strings.HasPrefix(split[index], ":") {\n        message.Source = *parseIRCMessageSource(split[index])\n        index++\n    }\n\n    if index >= len(split) {\n        return &message, fmt.Errorf("parseIRCMessage: no command")\n    }\n\n    message.Command = split[index]\n    index++\n\n    if index >= len(split) {\n        return &message, nil\n    }\n\n    var params []string\n    for i, v := range split[index:] {\n        if strings.HasPrefix(v, ":") {\n            v = strings.Join(split[index+i:], " ")\n            v = strings.TrimPrefix(v, ":")\n            params = append(params, v)\n            break\n        }\n\n        params = append(params, v)\n    }\n\n    message.Params = params\n\n    return &message, nil\n}\n\nfunc parseIRCTags(rawTags string) map[string]string {\n    tags := make(map[string]string)\n\n    rawTags = strings.TrimPrefix(rawTags, "@")\n\n    for _, tag := range strings.Split(rawTags, ";") {\n        pair := strings.SplitN(tag, "=", 2)\n        key := pair[0]\n\n        var value string\n        if len(pair) == 2 {\n            value = parseIRCTagValue(pair[1])\n        }\n\n        tags[key] = value\n    }\n\n    return tags\n}\n\nvar tagEscapeCharacters = []struct {\n    from string\n    to   string\n}{\n    {`\\s`, ` `},\n    {`\\n`, ``},\n    {`\\r`, ``},\n    {`\\:`, `;`},\n    {`\\\\`, `\\`},\n}\n\nfunc parseIRCTagValue(rawValue string) string {\n    for _, escape := range tagEscapeCharacters {\n        rawValue = strings.ReplaceAll(rawValue, escape.from, escape.to)\n    }\n\n    rawValue = strings.TrimSuffix(rawValue, "\\\\")\n    rawValue = strings.TrimSpace(rawValue)\n\n    return rawValue\n}\n\nfunc parseIRCMessageSource(rawSource string) *ircMessageSource {\n    var source ircMessageSource\n\n    rawSource = strings.TrimPrefix(rawSource, ":")\n\n    regex := regexp.MustCompile(`!|@`)\n    split := regex.Split(rawSource, -1)\n\n    if len(split) == 0 {\n        return &source\n    }\n\n    switch len(split) {\n    case 1:\n        source.Host = split[0]\n    case 2:\n        source.Nickname = split[0]\n        source.Host = split[1]\n    default:\n        source.Nickname = split[0]\n        source.Username = split[1]\n        source.Host = split[2]\n    }\n\n    return &source\n}\n\nfunc postServer() {\n    http.HandleFunc("/increment", func(w http.ResponseWriter, r *http.Request) {\n        if r.Method != http.MethodPost {\n            http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)\n            return\n        }\n\n        // Read the JSON file\n        file, _ := ioutil.ReadFile("counter.json")\n        var data myData\n        json.Unmarshal(file, &data)\n\n        // Increment the number\n        data.Fbombs++\n\n        // Write the updated data to the JSON file\n        updatedData, _ := json.MarshalIndent(data, "", "    ")\n        ioutil.WriteFile("counter.json", updatedData, 0644)\n\n        log.Println("[+] Incremented successfully")\n        w.Write([]byte("fbombs incremented successfully"))\n    })\n\n    http.HandleFunc("/reset", func(w http.ResponseWriter, r *http.Request) {\n        // Read the JSON file\n        file, _ := ioutil.ReadFile("counter.json")\n        var data myData\n        json.Unmarshal(file, &data)\n\n        // Increment the number\n        data.Fbombs = 0\n\n        // Write the updated data to the JSON file\n        updatedData, _ := json.MarshalIndent(data, "", "    ")\n        ioutil.WriteFile("counter.json", updatedData, 0644)\n\n        log.Println("[+] Counter reset to zero")\n        w.Write([]byte("Reset counter to zero"))\n    })\n\n    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {\n        http.ServeFile(w, r, "counter.json")\n    })\n\n    http.ListenAndServe(":8085", nil)\n}\n\nfunc main() {\n    fmt.Println(`\n.--.\n|__| .-------.\n|=.| |.-----.|\n|--| || TTV ||\n|  | |\'-----\'|\n|__|~\')_____(\'\n>>F-Bomb Bot<<\n`)\n\n    go postServer()\n\n    SetupCloseHandler()\n    const username string = "ringomar" // Set your bot\'s user name \n    const channel string = "ringomar" // Set your channel you want to join\n\n    chat := connect(username, "oauth:123") // Your Oauth Key here\n    chat.join(channel)\n\n    for message := range chat.messages {\n        if strings.HasPrefix(message, "PING") {\n            chat.send("PONG :tmi.twitch.tv")\n            continue\n        }\n\n        ircTranslate, _ := parseIRCMessage(message)\n        if ircTranslate.Command == "PRIVMSG" && len(ircTranslate.Params) > 1 {\n            cooldownTime := int(time.Since(lastUsed).Seconds())\n            if cooldownTime >= 120 && ircTranslate.Params[1] == "?fbomb" {\n                file, _ := ioutil.ReadFile("counter.json")\n                var data myData\n                json.Unmarshal(file, &data)\n                returnMes := fmt.Sprintf("The F word has been heard on this stream: %d times!", data.Fbombs)\n                lastUsed = time.Now()\n                chat.say(channel, returnMes)\n            }\n        }\n    }\n}\nfunc SetupCloseHandler() {\n    c := make(chan os.Signal)\n    signal.Notify(c, os.Interrupt, syscall.SIGTERM)\n    go func() {\n        <-c\n        fmt.Println("\\n\\n\\r- Ctrl+C pressed in Terminal")\n        os.Exit(0)\n    }()\n}\n\ntype irc struct {\n    conn     net.Conn\n    messages chan string\n}\n\nfunc connect(username, oauth string) *irc {\n    fmt.Printf("[%s][RIN-Connect] Dialing TCP server.\\n", string(time.Now().Format(time.Stamp)))\n\n    conn, err := tls.Dial("tcp", "irc.chat.twitch.tv:443", nil)\n    if err != nil {\n        log.Fatal("cannot connect to twitch irc server", err)\n    }\n    i := &irc{\n        conn:     conn,\n        messages: make(chan string, 10),\n    }\n    i.send("PASS " + oauth)\n    i.send("NICK " + username)\n    i.send("CAP REQ twitch.tv/membership")\n    i.send("CAP REQ twitch.tv/commands")\n    i.send("CAP REQ twitch.tv/tags")\n    go i.read()\n\n    fmt.Printf("[%s][RIN-Connect] connected to Twitch irc server\\n", string(time.Now().Format(time.Stamp)))\n    return i\n}\n\nfunc (i *irc) join(channel string) {\n    i.send("JOIN #" + strings.ToLower(channel))\n    fmt.Printf("[%s][RIN-Connect] Joined channel: %s\\n", string(time.Now().Format(time.Stamp)), channel)\n\n}\n\nfunc (i *irc) send(msg string) {\n    _, err := i.conn.Write([]byte(msg + "\\r\\n"))\n    if err != nil {\n        log.Fatal("Disconnected from twitch irc server", err)\n    }\n}\n\nfunc (i *irc) say(channel, msg string) {\n    fmt.Printf("[%s][RIN-SAY] sending #%s: %s\\n", string(time.Now().Format(time.Stamp)), channel, msg)\n    i.send(fmt.Sprintf("PRIVMSG #%s :%s", channel, msg))\n}\n\nfunc (i *irc) read() {\n    reader := bufio.NewReader(i.conn)\n    tp := textproto.NewReader(reader)\n    for {\n        message, err := tp.ReadLine()\n        if err != nil {\n            log.Fatal("Disconnected from twitch irc server", err)\n        }\n        i.messages <- message\n    }\n}\n\n')),(0,i.kt)("p",null,"Sometimes it wont auto connect still yet to figure that out, but running it again it works."))}p.isMDXComponent=!0}}]);